# AI/ML ì•„í‚¤í…ì²˜ ìƒì„¸

## ğŸ¤– AI/ML í•µì‹¬ ê¸°ìˆ 

### 1. SurvivalGNN ëª¨ë¸ ì•„í‚¤í…ì²˜

**GraphSAGE ê¸°ë°˜ ìƒì¡´ ë¶„ì„ ëª¨ë¸**

```python
class SurvivalGNN(nn.Module):
    def __init__(self, in_dim, hid=64, out_hazards=5):
        self.conv1 = SAGEConv(in_dim, hid)      # 1ì°¨ ì´ì›ƒ ì§‘ê³„
        self.conv2 = SAGEConv(hid, hid)         # 2ì°¨ ì´ì›ƒ ì§‘ê³„
        self.head = nn.Linear(hid, out_hazards) # 5ê°œë…„ hazard ì˜ˆì¸¡
```

- **ì…ë ¥**: í™˜ê²½ í”¼ì²˜ + ì—…ì¢… One-Hot (ì•½ 100+ ì°¨ì›)
- **ì¶œë ¥**: 1~5ë…„ì°¨ hazard rate (ì—°ë„ë³„ íì—… í™•ë¥ )
- **í™œì„±í™”**: ReLU â†’ Sigmoid (hazardë¥¼ 0~1ë¡œ ë³€í™˜)

### 2. ë™ì  ì„œë¸Œê·¸ë˜í”„ ìƒì„± (Augmented Subgraph)

**ì„ì˜ ì¢Œí‘œì—ì„œ ì˜ˆì¸¡ ê°€ëŠ¥í•œ ê°€ìƒ ë…¸ë“œ ê¸°ë²•**

**í”„ë¡œì„¸ìŠ¤:**

1. **ì…ë ¥**
   - ì¿¼ë¦¬ ì¢Œí‘œ: `(lat, lon)`
   - ì—…ì¢…: `category_id`

2. **KDTree Query ì¸ê·¼ íƒìƒ‰**
   - ì¸ê·¼ kê°œ ì§€ì—­ ë…¸ë“œ íƒìƒ‰
   - ê±°ë¦¬ ê¸°ë°˜ ê°€ì¤‘ì¹˜ ê³„ì‚° (ì—­ê±°ë¦¬ ê°€ì¤‘)

3. **ê°€ìƒ ë…¸ë“œ(Virtual) ìƒì„±**
   - í™˜ê²½ í”¼ì²˜ ë¸”ë Œë”© (ê°€ì¤‘ í‰ê· )
   - ì—…ì¢… One-Hot ì¸ì½”ë”© ì¶”ê°€
   - ê²½ìŸ ë°€ë„ ì ìˆ˜ ì£¼ì…

4. **ì„œë¸Œê·¸ë˜í”„ êµ¬ì„±**
   - ê°€ìƒ ë…¸ë“œ â†” ì¸ê·¼ ì§€ì—­ ë…¸ë“œ ì—£ì§€ ìƒì„±
   - ì¶”ë¡ ì„ ìœ„í•œ ì„œë¸Œê·¸ë˜í”„ ì™„ì„±

**í•µì‹¬ ì•Œê³ ë¦¬ì¦˜**
```python
# 1. ì¸ê·¼ ì§€ì—­ ê°€ì¤‘ì¹˜ ê³„ì‚° (ê±°ë¦¬ ì—­ìˆ˜)
w = 1.0 / (distance + 1e-6)
w /= w.sum()  # ì •ê·œí™”

# 2. í™˜ê²½ í”¼ì²˜ ë¸”ë Œë”©
env_mix = Î£ (w_i Ã— region_vector_i)

# 3. ê²½ìŸ ë°€ë„ ì ìˆ˜ (Gaussian Weighted)
competition_score = Î£ exp(-(dÂ²) / (2ÏƒÂ²))
normalized_competition = 1.0 / (1.0 + 0.05 Ã— competition_score)
```

### 3. Hazard-to-Survival ë³€í™˜

**ì—°ë„ë³„ ëˆ„ì  ìƒì¡´ìœ¨ ê³„ì‚°**

```python
# Hazard Rate â†’ Survival Probability
def hazard_to_survival(hazards):
    survival = 1.0
    S = []
    for p in hazards:  # p = í•´ë‹¹ ì—°ë„ íì—… í™•ë¥ 
        survival *= (1.0 - p)
        S.append(survival)
    return S  # [S1, S2, S3, S4, S5]

# ì˜ˆì‹œ:
# hazard = [0.15, 0.12, 0.10, 0.08, 0.07]
# survival = [0.85, 0.75, 0.67, 0.62, 0.58]
# failure = [0.15, 0.25, 0.33, 0.38, 0.42]
```

### 4. í™˜ê²½ í”¼ì²˜ êµ¬ì„±

**7ê°œ í•µì‹¬ í™˜ê²½ í”¼ì²˜**

| í”¼ì²˜ëª… | ì„¤ëª… | ì˜í–¥ |
|--------|------|------|
| `pop` | ê±°ì£¼ ì¸êµ¬ | ì†Œë¹„ì í’€ í¬ê¸° |
| `work_pop` | ì§ì¥ ì¸êµ¬ (ì¶œí‡´ê·¼) | í‰ì¼ ìœ ë™ ì¸êµ¬ |
| `bus_stop_count` | ë²„ìŠ¤ ì •ë¥˜ì¥ ìˆ˜ | ì ‘ê·¼ì„± |
| `school_count` | í•™êµ ìˆ˜ | í•™ìƒ ì¸êµ¬ ë°€ë„ |
| `library_count` | ë„ì„œê´€ ìˆ˜ | ë¬¸í™” ì‹œì„¤ ë°€ì§‘ë„ |
| `nightview_count` | ì•¼ê°„ ìœ ë™ ìŠ¤íŒŸ | ì•¼ê°„ ìƒê¶Œ í™œì„±ë„ |
| `subway_traffic` | ì§€í•˜ì²  ìœ ë™ëŸ‰ | ëŒ€ì¤‘êµí†µ ì ‘ê·¼ì„± |

**í”¼ì²˜ ì •ê·œí™”**
```python
# Min-Max Normalization (0~1)
normalized_value = raw_value / region_max[feature_name]
```

### 5. Explainable AI (XAI) - ì˜ˆì¸¡ ê·¼ê±° ì„¤ëª…

**3ë‹¨ê³„ ì„¤ëª… ìƒì„± íŒŒì´í”„ë¼ì¸**

**í”¼ì²˜ ê¸°ì—¬ë„ ë¶„ì„** â†’ **ì˜í–¥ë„ ì •ëŸ‰í™” (ë²„í‚· ë¶„ë¥˜)** â†’ **LLM ìì—°ì–´í™” (GPT ì„¤ëª…)**

**í”¼ì²˜ ì˜í–¥ë„ ë¶„ë¥˜**
```python
def _bucket(score: float):
    if score >= 0.60: return "ë§¤ìš° í¼"
    elif score >= 0.35: return "í¼"
    elif score >= 0.20: return "ë³´í†µ"
    elif score > 0.05: return "ì•½í•¨"
    else: return "ë§¤ìš° ì•½í•¨"
```

**LLM í”„ë¡¬í”„íŠ¸ êµ¬ì„±**
```python
sys_prompt = """
ë„ˆëŠ” ìƒê¶Œ ë°ì´í„° ë¶„ì„ê°€ì•¼. ì•„ë˜ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ
'ì™œ ì´ ì—…ì¢…ì˜ íì—… ìœ„í—˜ì´ ê·¸ë ‡ê²Œ ë‚˜ì™”ëŠ”ì§€'ë¥¼
ë¹„ì „ë¬¸ê°€(ì ì£¼)ë„ ì´í•´í•  ìˆ˜ ìˆëŠ” í•œêµ­ì–´ë¡œ ì„¤ëª…í•´.

ê·œì¹™:
1) 'ì—£ì§€, ë…¸ë“œ, ì„ë² ë”©' ê°™ì€ ê¸°ìˆ  ìš©ì–´ ì‚¬ìš© ê¸ˆì§€
2) ìˆ«ì ëŒ€ì‹  ê°•ë„ë¡œ í‘œí˜„ (ë§¤ìš° ë†’ìŒ, ë³´í†µ ë“±)
3) ì¥ì /ë¦¬ìŠ¤í¬ ê· í˜• ìˆê²Œ ìš”ì•½
"""
```

**ì‘ë‹µ ì˜ˆì‹œ**
```json
{
  "explain": "í•´ë‹¹ ìœ„ì¹˜ëŠ” ê±°ì£¼ ì¸êµ¬ê°€ ë§ê³  ì§€í•˜ì²  ìœ ë™ëŸ‰ì´ ë†’ì•„
              ì ‘ê·¼ì„±ì´ ì¢‹ìŠµë‹ˆë‹¤. ë‹¤ë§Œ ì£¼ë³€ì— ë™ì¼ ì—…ì¢… ì í¬ê°€
              ë‹¤ì†Œ ë°€ì§‘í•´ ìˆì–´ ê²½ìŸì´ ì˜ˆìƒë©ë‹ˆë‹¤. ì¢…í•©ì ìœ¼ë¡œ
              í•´ë‹¹ ì—…ì¢…ì˜ íì—… ìœ„í—˜ì€ ë³´í†µ ìˆ˜ì¤€ìœ¼ë¡œ íŒë‹¨ë©ë‹ˆë‹¤."
}
```

---

## ğŸ“Š AI ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ Pipeline

```mermaid
graph LR
    A[ì‚¬ìš©ì ì…ë ¥] --> B[KDTree Query]
    B --> C[ê°€ì¤‘ì¹˜ ê³„ì‚°]
    C --> D[í”¼ì²˜ ë¸”ë Œë”©]
    D --> E[ê²½ìŸ ë°€ë„]
    E --> F[ê°€ìƒ ë…¸ë“œ ìƒì„±]
    F --> G[ì„œë¸Œê·¸ë˜í”„ êµ¬ì„±]
    G --> H[GNN ì¶”ë¡ ]
    H --> I[Survival ë³€í™˜]
    I --> J[ìˆœìœ„ ì •ë ¬]
    J --> K[XAI ì„¤ëª…]
    K --> L[ê²°ê³¼ ë°˜í™˜]
```

**ìƒì„¸ ë‹¨ê³„:**
1. **ì‚¬ìš©ì ì…ë ¥**: ìœ„ì¹˜(lat, lon) + ì—…ì¢…(category_id)
2. **KDTree Query**: ì¸ê·¼ kê°œ ì§€ì—­ ë…¸ë“œ íƒìƒ‰
3. **ê°€ì¤‘ì¹˜ ê³„ì‚°**: ê±°ë¦¬ ê¸°ë°˜ w = 1/(d + Îµ)
4. **í”¼ì²˜ ë¸”ë Œë”©**: í™˜ê²½ íŠ¹ì§• ê°€ì¤‘ í‰ê· 
5. **ê²½ìŸ ë°€ë„**: Gaussian Weighted ê³„ì‚°
6. **ê°€ìƒ ë…¸ë“œ ìƒì„±**: env_vec + category_onehot
7. **ì„œë¸Œê·¸ë˜í”„ êµ¬ì„±**: Virtual â†” Region Edges
8. **GNN ì¶”ë¡ **: SurvivalGNN (GraphSAGE 2-layer)
9. **Survival ë³€í™˜**: Hazard â†’ ëˆ„ì  ìƒì¡´ìœ¨
10. **ìˆœìœ„ ì •ë ¬**: 5ë…„ì°¨ íì—…ë¥  ê¸°ì¤€
11. **XAI ì„¤ëª…**: í”¼ì²˜ ê¸°ì—¬ë„ + LLM ìì—°ì–´í™”
12. **ê²°ê³¼ ë°˜í™˜**: JSON ì‘ë‹µ

---

## ğŸ”¬ AI ì¶”ë¡  ì—”ì§„ ìƒì„¸

### 1. ì„œë¸Œê·¸ë˜í”„ ìƒì„± (Subgraph Construction)

#### ì¸ê·¼ ì§€ì—­ íƒìƒ‰ (KDTree Query)
```python
# kê°œ ì¸ê·¼ ì§€ì—­ ë…¸ë“œ íƒìƒ‰
d, idxs = node_tree.query([lat, lon], k=k_region)

# ê±°ë¦¬ ê¸°ë°˜ ê°€ì¤‘ì¹˜ (ì—­ìˆ˜)
w = 1.0 / (d + 1e-6)
w /= w.sum()  # ì •ê·œí™”
```

#### í™˜ê²½ í”¼ì²˜ ë¸”ë Œë”©
```python
# ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ê°€ìƒ ë…¸ë“œ í™˜ê²½ ë²¡í„° ìƒì„±
env_mix = np.zeros(env_feat_count)
for region_code, weight in zip(codes, w):
    env_mix += weight * region_vector(region_code)

# ê°ë§ˆ ë³´ì • ë° ê²Œì¸ ì ìš©
env_mix = np.power(env_mix, env_gamma)
env_mix = np.clip(env_mix * env_gain, 0.0, 1.0)
```

#### ê²½ìŸ ë°€ë„ ì ìˆ˜ ì£¼ì…
```python
# 300m ë°˜ê²½ ë‚´ ìƒê°€ íƒìƒ‰
radius_deg = 0.3 / 111.1  # ~300m
nearby_indices = store_tree.query_ball_point([lat, lon], r=radius_deg)

# Gaussian Weighted ê²½ìŸ ì ìˆ˜
sigma = 0.1  # km
weights = np.exp(-(distances**2) / (2 * sigma**2))
competition_score = np.sum(weights)

# ì •ê·œí™” (ë†’ì„ìˆ˜ë¡ ê²½ìŸ ì‹¬í•¨ â†’ ë‚®ì€ ì ìˆ˜)
normalized = 1.0 / (1.0 + 0.05 * competition_score)
```

### 2. GNN ì¶”ë¡  (Model Inference)

#### ëª¨ë¸ êµ¬ì¡°
```
Input: [env_features(7) + category_onehot(N)] â†’ ~100+ dims
    â”‚
    â–¼
SAGEConv(in_dim â†’ 64) + ReLU
    â”‚
    â–¼
SAGEConv(64 â†’ 64) + ReLU
    â”‚
    â–¼
Linear(64 â†’ 5) â†’ Sigmoid
    â”‚
    â–¼
Output: [hazard_1y, hazard_2y, hazard_3y, hazard_4y, hazard_5y]
```

#### ì¶”ë¡  ì½”ë“œ
```python
@torch.no_grad()
async def predict_hazards_at_location(ctx, lat, lon, cid, knobs):
    # ì„œë¸Œê·¸ë˜í”„ ìƒì„±
    sub, v_idx = await build_augmented_subgraph_for_category(
        ctx, lat, lon, cid, knobs
    )

    # ì°¨ì› ë³´ì •
    sub.x = _ensure_feature_dim(sub.x, target_dim)

    # ëª¨ë¸ ì¶”ë¡ 
    ctx.model.eval()
    logits, _ = ctx.model(sub.x, sub.edge_index)
    hazard = torch.sigmoid(logits[v_idx]).numpy()

    # ìƒì¡´ìœ¨/íì—…ë¥  ë³€í™˜
    S, F = _hazard_to_survival_and_failure(hazard)

    return {"hazard": hazard, "survival": S, "failure": F}
```

### 3. í•˜ì´í¼íŒŒë¼ë¯¸í„° ì„¤ì •

| íŒŒë¼ë¯¸í„° | ê¸°ë³¸ê°’ | ì„¤ëª… |
|----------|--------|------|
| `k_region` | 5 | ì¸ê·¼ ì§€ì—­ íƒìƒ‰ ê°œìˆ˜ |
| `k_max_ratio` | 2.0 | ìµœëŒ€ ê±°ë¦¬ ë¹„ìœ¨ ì œí•œ |
| `edge_gain` | 1.0 | ì—£ì§€ ê°€ì¤‘ì¹˜ ì¦í­ |
| `env_gain` | 1.0 | í™˜ê²½ í”¼ì²˜ ê²Œì¸ |
| `env_gamma` | 1.0 | í™˜ê²½ í”¼ì²˜ ê°ë§ˆ ë³´ì • |
| `DISTANCE_SIGMA_KM` | 0.1 | ê²½ìŸ ì ìˆ˜ ê°€ìš°ì‹œì•ˆ Ïƒ |

---

## ğŸ’¡ í•µì‹¬ ì„±ê³¼ ë° ì°¨ë³„ì 

### ğŸ¯ ê¸°ìˆ ì  ì„±ê³¼

1. **GraphSAGE ê¸°ë°˜ ìƒì¡´ ë¶„ì„**
   - ë…¸ë“œ íŠ¹ì„± ì§‘ê³„(Aggregation)ë¡œ ì¸ê·¼ ìƒê¶Œ ì˜í–¥ ë°˜ì˜
   - 2-layer êµ¬ì¡°ë¡œ 2-hop ì´ì›ƒ ì •ë³´ í™œìš©
   - Half-precision (FP16) ì¶”ë¡ ìœ¼ë¡œ ë©”ëª¨ë¦¬/ì†ë„ ìµœì í™”

2. **ë™ì  ì„œë¸Œê·¸ë˜í”„ ê¸°ë²•**
   - í•™ìŠµ ì‹œ ì—†ë˜ ì„ì˜ ì¢Œí‘œì—ì„œë„ ì˜ˆì¸¡ ê°€ëŠ¥
   - ê°€ìƒ ë…¸ë“œ + ì¸ê·¼ ì§€ì—­ ë…¸ë“œë¡œ ì„œë¸Œê·¸ë˜í”„ êµ¬ì„±
   - KDTree ê¸°ë°˜ O(log N) ì´ì›ƒ íƒìƒ‰

3. **ë‹¤ì°¨ì› í”¼ì²˜ ì—”ì§€ë‹ˆì–´ë§**
   - ì¸êµ¬, êµí†µ, ê²½ìŸ ë°€ë„ ë“± 7ê°œ í™˜ê²½ í”¼ì²˜
   - Gaussian Weighted ê²½ìŸ ì ìˆ˜ë¡œ ì§€ì—­ í¬í™”ë„ ë°˜ì˜
   - ì—…ì¢… One-Hot ì¸ì½”ë”©ìœ¼ë¡œ ì—…ì¢… íŠ¹ì„± êµ¬ë¶„

4. **Explainable AI êµ¬í˜„**
   - í”¼ì²˜ë³„ ê¸°ì—¬ë„ ë¶„ì„ (ì˜í–¥ë„ ë²„í‚· ë¶„ë¥˜)
   - LLM ê¸°ë°˜ ìì—°ì–´ ì„¤ëª… ìƒì„± (ë¹„ì „ë¬¸ê°€ ì¹œí™”ì )
   - ì„¤ëª… ì‹¤íŒ¨ ì‹œ ê·œì¹™ ê¸°ë°˜ í´ë°± ì œê³µ

### ğŸš€ í™•ì¥ ê°€ëŠ¥ì„±

- **ì‹œê³„ì—´ í™•ì¥**: ì‹œì ë³„ ìƒê¶Œ ë³€í™” ë°˜ì˜ (Temporal GNN)
- **í”¼ë“œë°± í•™ìŠµ**: ì‹¤ì œ íì—… ë°ì´í„°ë¡œ ëª¨ë¸ ì¬í•™ìŠµ
- **ë‹¤ì¤‘ íƒ€ê²Ÿ**: ë§¤ì¶œ ì˜ˆì¸¡, ì„ëŒ€ë£Œ ì˜ˆì¸¡ ë“± í™•ì¥

### ğŸ“ˆ ê¸°ëŒ€ íš¨ê³¼

- **ì˜ì‚¬ê²°ì • ì§€ì›**: ë°ì´í„° ê¸°ë°˜ ì…ì§€ ì„ ì •ìœ¼ë¡œ ì°½ì—… ë¦¬ìŠ¤í¬ ê°ì†Œ
- **ì •ëŸ‰ì  ë¹„êµ**: ì—…ì¢…ë³„ íì—…ë¥  ìˆœìœ„ë¡œ ê°ê´€ì  ë¹„êµ ê°€ëŠ¥
- **ê·¼ê±° ì œê³µ**: XAI ì„¤ëª…ìœ¼ë¡œ ì˜ˆì¸¡ ì‹ ë¢°ë„ í–¥ìƒ
